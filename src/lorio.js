function readInterruptSignal(timeoutMillis) {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error("read timeout")), timeoutMillis);
  });
}

function groupMessages(msg) {
  let groups = [];

  let currentGroupStart = false;

  for (let i = 0; i < msg.length; i++) {
    if (msg[i] !== 0) {
      // start of group
      if (currentGroupStart === false) {
        currentGroupStart = i;
      }
    } else {
      // end of group
      if (currentGroupStart !== false) {
        groups.push(msg.slice(currentGroupStart, i));

        currentGroupStart = false;
      }
    }
  }

  // dangling group
  if (currentGroupStart !== false) {
    groups.push(msg.slice(currentGroupStart, msg.length));
  }

  return groups;
}

export class LorIO {
  #serialPort;
  #readInterrupt = false;

  constructor(serialPort) {
    this.#serialPort = serialPort;
  }

  async read(timeoutMillis = 2500) {
    let sum = new Uint8Array([]);

    // messages may be broken into several read calls,
    // and without full protocol documentation we don't know
    // when a fully valid response is received
    // this helps ensures the inbound buffer is fully read
    // each read try is given a 500ms allowance
    let readTryCount = Math.max(timeoutMillis / 500);

    while (
      this.#serialPort.readable &&
      readTryCount > 0 &&
      !this.#readInterrupt
    ) {
      readTryCount--;

      let reader = this.#serialPort.readable.getReader();

      try {
        let { value, done } = await Promise.race([
          reader.read(),
          readInterruptSignal(500), // read in 500ms blocks, up to the full `timeoutMillis` value
        ]);

        if (done) {
          break;
        } else if (value && value.length > 0) {
          let newSum = new Uint8Array(sum.length + value.length);

          newSum.set(sum);
          newSum.set(value, sum.length);

          sum = newSum;
        }
      } catch (err) {
        // ignore errors directly generated by interrupt signal
        if (err.message !== "read timeout") {
          console.error(err);
        }
      } finally {
        reader.releaseLock();
      }
    }

    if (this.#readInterrupt) {
      throw new Error("read interrupt");
    }

    return groupMessages(sum);
  }

  async #setRequestToSend(b) {
    await this.#serialPort.setSignals({
      requestToSend: b,
    });
  }

  async write(msg) {
    if (this.#serialPort.writable) {
      const writer = this.#serialPort.writable.getWriter();

      try {
        let data = new Uint8Array([0x00, ...msg, 0x00]);

        await this.#setRequestToSend(true);
        await writer.write(data);
      } finally {
        writer.releaseLock();

        await this.#setRequestToSend(false);
      }
    }
  }

  async close() {
    this.#readInterrupt = true;

    try {
      await this.#serialPort?.close();
      await this.#serialPort?.forget();
    } catch (ex) {
      console.error("ignoring error while closing serialPort:", ex);
    }
  }

  isConnected() {
    if (!this.#serialPort) {
      return false;
    }

    return this.#serialPort.readable && this.#serialPort.writable;
  }
}
